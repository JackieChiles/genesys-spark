import { r as registerInstance, h, g as getElement } from './index-f583fcde.js';
import { c as createCommonjsModule, a as commonjsGlobal } from './_commonjsHelpers-93ec9c7a.js';
import { a as onDisabledChange } from './on-attribute-change-5fd8da7c.js';

var performanceNow = createCommonjsModule(function (module) {
// Generated by CoffeeScript 1.12.2
(function() {
  var getNanoSeconds, hrtime, loadTime, moduleLoadTime, nodeLoadTime, upTime;

  if ((typeof performance !== "undefined" && performance !== null) && performance.now) {
    module.exports = function() {
      return performance.now();
    };
  } else if ((typeof process !== "undefined" && process !== null) && process.hrtime) {
    module.exports = function() {
      return (getNanoSeconds() - nodeLoadTime) / 1e6;
    };
    hrtime = process.hrtime;
    getNanoSeconds = function() {
      var hr;
      hr = hrtime();
      return hr[0] * 1e9 + hr[1];
    };
    moduleLoadTime = getNanoSeconds();
    upTime = process.uptime() * 1e9;
    nodeLoadTime = moduleLoadTime - upTime;
  } else if (Date.now) {
    module.exports = function() {
      return Date.now() - loadTime;
    };
    loadTime = Date.now();
  } else {
    module.exports = function() {
      return new Date().getTime() - loadTime;
    };
    loadTime = new Date().getTime();
  }

}).call(commonjsGlobal);

//# sourceMappingURL=performance-now.js.map
});

var root = typeof window === 'undefined' ? commonjsGlobal : window
  , vendors = ['moz', 'webkit']
  , suffix = 'AnimationFrame'
  , raf = root['request' + suffix]
  , caf = root['cancel' + suffix] || root['cancelRequest' + suffix];

for(var i = 0; !raf && i < vendors.length; i++) {
  raf = root[vendors[i] + 'Request' + suffix];
  caf = root[vendors[i] + 'Cancel' + suffix]
      || root[vendors[i] + 'CancelRequest' + suffix];
}

// Some versions of FF have rAF but not cAF
if(!raf || !caf) {
  var last = 0
    , id = 0
    , queue = []
    , frameDuration = 1000 / 60;

  raf = function(callback) {
    if(queue.length === 0) {
      var _now = performanceNow()
        , next = Math.max(0, frameDuration - (_now - last));
      last = next + _now;
      setTimeout(function() {
        var cp = queue.slice(0);
        // Clear queue here to prevent
        // callbacks from appending listeners
        // to the current frame's queue
        queue.length = 0;
        for(var i = 0; i < cp.length; i++) {
          if(!cp[i].cancelled) {
            try{
              cp[i].callback(last);
            } catch(e) {
              setTimeout(function() { throw e }, 0);
            }
          }
        }
      }, Math.round(next));
    }
    queue.push({
      handle: ++id,
      callback: callback,
      cancelled: false
    });
    return id
  };

  caf = function(handle) {
    for(var i = 0; i < queue.length; i++) {
      if(queue[i].handle === handle) {
        queue[i].cancelled = true;
      }
    }
  };
}

var raf_1 = function(fn) {
  // Wrap in a new function to prevent
  // `cancel` potentially being assigned
  // to the native rAF function
  return raf.call(root, fn)
};
var cancel = function() {
  caf.apply(root, arguments);
};
var polyfill = function(object) {
  if (!object) {
    object = root;
  }
  object.requestAnimationFrame = raf;
  object.cancelAnimationFrame = caf;
};
raf_1.cancel = cancel;
raf_1.polyfill = polyfill;

var MODE;
(function (MODE) {
    MODE[MODE["MODE_TIMEOUT"] = 0] = "MODE_TIMEOUT";
    MODE[MODE["MODE_INTERVAL"] = 1] = "MODE_INTERVAL";
})(MODE || (MODE = {}));
const fnMap = new Map();
const executionSet = new Set();
let rafStarted = false;
let startId = 0;
function getTimeStamp() {
    return new Date().getTime();
}
function executeFn(value) {
    const { fn, args } = value;
    fn(...args);
}
function runFunction() {
    if (executionSet.size === 0)
        return;
    executionSet.forEach(executeFn);
    executionSet.clear();
}
const checkTick = (currentTimeTick) => (value, id) => {
    const { nextTick, ms, mode } = value;
    if (currentTimeTick - nextTick >= 0) {
        executionSet.add(value);
        if (mode === MODE.MODE_TIMEOUT) {
            fnMap.delete(id);
        }
        else {
            fnMap.set(id, {
                ...value,
                nextTick: nextTick + ms,
            });
        }
    }
};
function loop() {
    if (fnMap.size === 0) {
        rafStarted = false;
        return;
    }
    const currentTimeTick = getTimeStamp();
    fnMap.forEach(checkTick(currentTimeTick));
    runFunction();
    if (fnMap.size === 0) {
        rafStarted = false;
        return;
    }
    raf_1(loop);
}
function addId({ fn, ms, args, mode }) {
    if (!fn)
        return null;
    const currentId = startId;
    fnMap.set(currentId, {
        fn,
        ms,
        nextTick: getTimeStamp() + ms,
        args,
        mode,
    });
    if (!rafStarted) {
        rafStarted = true;
        raf_1(loop);
    }
    startId += 1;
    return currentId;
}
function removeId(id) {
    if (id == null)
        return;
    if (fnMap.has(id)) {
        fnMap.delete(id);
    }
}
const setTimeout$1 = (fn, ms = 0, ...args) => addId({ fn, ms, args, mode: MODE.MODE_TIMEOUT });
const clearTimeout = removeId;
const setInterval = (fn, ms = 0, ...args) => addId({ fn, ms, args, mode: MODE.MODE_INTERVAL });
const clearInterval = removeId;
const index = { setTimeout: setTimeout$1, clearTimeout, setInterval, clearInterval };

const guxInputRangeCss = "gux-input-range .gux-container{display:flex;flex-direction:row;flex-wrap:nowrap;align-content:stretch;align-items:center;justify-content:flex-start;height:32px;font-size:12px}gux-input-range .gux-container.gux-disabled{pointer-events:none;opacity:0.5}gux-input-range .gux-container .gux-range{position:relative;flex:1 1 auto;align-self:center;order:0}gux-input-range .gux-container .gux-range .gux-track{width:100%;height:2px;margin:6px 0;background-color:#8a97ad}gux-input-range .gux-container .gux-range .gux-track .gux-progress{height:2px;background-color:#2a60c8}gux-input-range .gux-container .gux-range input[type='range']{position:absolute;width:100%;height:2px;margin:6px 0;margin-top:calc(-1 * (12px / 2 + 2px));background:transparent;-webkit-appearance:none}gux-input-range .gux-container .gux-range input[type='range']:focus{outline:none}gux-input-range .gux-container .gux-range input[type='range']::-webkit-slider-runnable-track{width:100%;height:2px;margin:6px 0;background-color:#8a97ad;background:transparent}gux-input-range .gux-container .gux-range input[type='range']::-webkit-slider-runnable-track .gux-progress{height:2px;background-color:#2a60c8}gux-input-range .gux-container .gux-range input[type='range']::-webkit-slider-thumb{display:block;width:12px;height:12px;cursor:pointer;border-radius:100%;margin-top:-5px;-webkit-appearance:none;background:#2a60c8;border:0 solid #2a60c8}gux-input-range .gux-container .gux-range input[type='range']:focus::-webkit-slider-runnable-track{background:rgba(13, 13, 13, 0)}gux-input-range .gux-container .gux-range input[type='range']::-moz-range-track{width:100%;height:2px;margin:6px 0;background-color:#8a97ad;background:transparent}gux-input-range .gux-container .gux-range input[type='range']::-moz-range-track .gux-progress{height:2px;background-color:#2a60c8}gux-input-range .gux-container .gux-range input[type='range']::-moz-range-thumb{display:block;width:12px;height:12px;cursor:pointer;border-radius:100%;margin-top:-5px;background:#2a60c8;border:0 solid #2a60c8}gux-input-range .gux-container .gux-range input[type='range']::-ms-track{width:100%;height:2px;margin:6px 0;background-color:#8a97ad;color:transparent;background:transparent;border-color:transparent;border-width:12px 0}gux-input-range .gux-container .gux-range input[type='range']::-ms-track .gux-progress{height:2px;background-color:#2a60c8}gux-input-range .gux-container .gux-range input[type='range']::-ms-fill-lower{background:rgba(0, 0, 0, 0)}gux-input-range .gux-container .gux-range input[type='range']::-ms-fill-upper{background:transparent}gux-input-range .gux-container .gux-range input[type='range']::-ms-thumb{display:block;width:12px;height:12px;cursor:pointer;border-radius:100%;background:#2a60c8;border:0 solid #2a60c8}gux-input-range .gux-container .gux-range input[type='range']:focus::-ms-fill-lower{background:transparent}gux-input-range .gux-container .gux-range input[type='range']:focus::-ms-fill-upper{background:rgba(13, 13, 13, 0)}gux-input-range .gux-container .gux-range.gux-active input[type='range']::-webkit-slider-thumb{transform:scale(1.5)}gux-input-range .gux-container .gux-range.gux-active input[type='range']::-moz-range-thumb{transform:scale(1.5)}gux-input-range .gux-container .gux-range.gux-active input[type='range']::-ms-thumb{transform:scale(1.5)}gux-input-range .gux-container .gux-display{flex:0 1 auto;align-self:auto;order:0;height:32px;margin:0 0 0 16px;line-height:32px;text-align:right}gux-input-range .gux-container .gux-display.gux-hidden{display:none}gux-input-range .gux-range-tooltip-container{position:absolute;top:-50px;width:100%;height:32px;visibility:hidden}gux-input-range .gux-range-tooltip-container .gux-range-tooltip{font-family:Roboto, sans-serif;font-weight:400;font-size:11px;line-height:16px;position:absolute;z-index:1;display:flex;align-items:center;justify-content:center;width:50px;height:32px;margin-left:-20px;visibility:hidden;background-color:#fdfdfd;border:1px solid #b4bccb;border-radius:4px;box-shadow:0 2px 4px rgba(32, 41, 55, 0.24)}gux-input-range .gux-range-tooltip-container .gux-range-tooltip::after,gux-input-range .gux-range-tooltip-container .gux-range-tooltip::before{position:absolute;top:100%;left:50%;width:0;height:0;pointer-events:none;content:' ';border:solid transparent}gux-input-range .gux-range-tooltip-container .gux-range-tooltip::after{margin-left:-4px;border-width:4px;border-top-color:#fdfdfd}gux-input-range .gux-range-tooltip-container .gux-range-tooltip::before{margin-left:-6px;border-width:6px;border-top-color:#b4bccb}gux-input-range input[type='range']:hover~.gux-range-tooltip-container:not(.gux-hidden),gux-input-range input[type='range']:focus~.gux-range-tooltip-container:not(.gux-hidden),gux-input-range input[type='range']:active~.gux-range-tooltip-container:not(.gux-hidden){visibility:visible}gux-input-range input[type='range']:hover~.gux-range-tooltip-container:not(.gux-hidden) .gux-range-tooltip,gux-input-range input[type='range']:focus~.gux-range-tooltip-container:not(.gux-hidden) .gux-range-tooltip,gux-input-range input[type='range']:active~.gux-range-tooltip-container:not(.gux-hidden) .gux-range-tooltip{visibility:visible}";

const GuxInputRange = class {
  constructor(hostRef) {
    registerInstance(this, hostRef);
    this.displayUnits = undefined;
    this.disabled = undefined;
    this.value = undefined;
    this.active = undefined;
    this.valueWatcherId = undefined;
    this.valueInTooltip = false;
  }
  onInput(e) {
    const input = e.target;
    this.updateValue(input.value);
  }
  onMousedown() {
    if (!this.disabled) {
      this.active = true;
    }
  }
  onMouseup() {
    this.active = false;
  }
  updateValue(newValue) {
    this.value = newValue;
    this.updatePosition();
  }
  updatePosition() {
    const value = Number(this.input.value || 0);
    const min = Number(this.input.min || 0);
    const max = Number(this.input.max || 100);
    const placementPercentage = ((value - min) / (max - min)) * 100;
    if (this.sliderTooltip) {
      const width = this.sliderTooltipContainer.offsetWidth;
      // Round tooltip position to the tenths place to prevent snapshot inconsistencies
      const offset = Math.round((placementPercentage / 100 - placementPercentage / 8 / width) * 1000) / 10;
      this.sliderTooltip.style.left = `${offset}%`;
    }
    this.progressElement.style.width = `${placementPercentage}%`;
  }
  getDisplayValue() {
    if (this.displayUnits) {
      return `${this.value}${this.displayUnits}`;
    }
    return this.value;
  }
  // Using componentWillLoad() instead of connectedCallback() here to fix
  // a bug caused by a race condition. Refer to COMUI-541 for details
  componentWillLoad() {
    this.input = this.root.querySelector('input[slot="input"]');
    this.disabled = this.input.disabled;
    this.value = this.input.value;
    this.disabledObserver = onDisabledChange(this.input, (disabled) => {
      this.disabled = disabled;
    });
    this.valueWatcherId = setInterval(() => {
      if (this.value !== this.input.value) {
        this.updateValue(this.input.value);
      }
    }, 100);
  }
  componentDidLoad() {
    this.updatePosition();
  }
  disconnectedCallback() {
    if (this.disabledObserver) {
      this.disabledObserver.disconnect();
    }
    clearInterval(this.valueWatcherId);
  }
  render() {
    return (h("div", { class: {
        'gux-container': true,
        'gux-disabled': this.disabled
      } }, h("div", { class: {
        'gux-range': true,
        'gux-active': this.active
      } }, h("div", { class: "gux-track" }, h("div", { class: "gux-progress", ref: el => (this.progressElement = el) })), h("slot", { name: "input" }), h("div", { class: {
        'gux-range-tooltip-container': true,
        'gux-hidden': !this.valueInTooltip
      }, ref: el => (this.sliderTooltipContainer = el) }, h("div", { class: "gux-range-tooltip", ref: el => (this.sliderTooltip = el) }, this.getDisplayValue()))), h("div", { class: {
        'gux-display': true,
        'gux-hidden': this.valueInTooltip
      } }, this.getDisplayValue())));
  }
  get root() { return getElement(this); }
};
GuxInputRange.style = guxInputRangeCss;

export { GuxInputRange as gux_input_range };
